/**
 * This module was automatically generated by `ts-interface-builder`
 */
import * as t from "ts-interface-checker";
// tslint:disable:object-literal-key-quotes

export const ITransitKeyType = t.union(t.lit("aes256-gcm96"), t.lit("chacha20-poly1305"), t.lit("d25519"), t.lit("ecdsa-p256"), t.lit("rsa-2048"), t.lit("rsa-4096"));

export const ITransitBatchPlaintext = t.array(t.iface([], {
  "plaintext": t.opt("string"),
  "context": t.opt("string"),
}));

export const ITransitBatchCiphertext = t.array(t.iface([], {
  "ciphertext": "string",
  "context": t.opt("string"),
}));

export const ITransitCreateOptions = t.iface([], {
  "convergent_encryption": t.opt("boolean"),
  "derived": t.opt("boolean"),
  "exportable": t.opt("boolean"),
  "allow_plaintext_backup": t.opt("boolean"),
  "type": t.opt("ITransitKeyType"),
});

export const ITransitReadResponse = t.iface([], {
  "data": t.iface([], {
    "type": "ITransitKeyType",
    "deletion_allowed": "boolean",
    "derived": "boolean",
    "exportable": "boolean",
    "allow_plaintext_backup": "boolean",
    "keys": t.iface([], {
    }),
    "min_decryption_version": "number",
    "min_encryption_version": "number",
    "name": "string",
    "supports_encryption": "boolean",
    "supports_decryption": "boolean",
    "supports_derivation": "boolean",
    "supports_signing": "boolean",
    "latest_version": t.opt("number"),
  }),
});

export const ITransitListResponse = t.iface([], {
  "data": t.iface([], {
    "keys": t.array("string"),
  }),
  "lease_duration": "number",
  "lease_id": "string",
  "renewable": "boolean",
});

export const ITransitUpdateOptions = t.iface([], {
  "min_decryption_version": t.opt("number"),
  "min_encryption_version": t.opt("number"),
  "deletion_allowed": t.opt("boolean"),
  "exportable": t.opt("boolean"),
  "allow_plaintext_backup": t.opt("boolean"),
});

export const ITransitExportOptions = t.iface([], {
  "key_type": t.union(t.lit("encryption-key"), t.lit("signing-key"), t.lit("hmac-key")),
  "version": t.opt(t.union("string", t.lit("latest"))),
});

export const ITransitExportResponse = t.iface([], {
  "data": t.iface([], {
    "name": "string",
    "keys": t.iface([], {
    }),
    "type": "ITransitKeyType",
  }),
});

export const ITransitEncryptOptionsSingle = t.iface([], {
  "plaintext": "string",
  "context": t.opt("string"),
  "key_version": t.opt("number"),
  "nonce": t.opt("string"),
  "type": t.opt("ITransitKeyType"),
  "convergent_encryption": t.opt("string"),
});

export const ITransitEncryptOptionsBatch = t.iface([], {
  "key_version": t.opt("number"),
  "batch_input": "ITransitBatchPlaintext",
  "type": t.opt("ITransitKeyType"),
  "convergent_encryption": t.opt("string"),
});

export const ITransitEncryptResponseSingle = t.iface([], {
  "data": t.iface([], {
    "ciphertext": "string",
  }),
});

export const ITransitEncryptResponseBatch = t.iface([], {
  "data": t.iface([], {
    "batch_results": "ITransitBatchCiphertext",
  }),
});

export const ITransitDecryptOptionsSingle = t.iface([], {
  "ciphertext": "string",
  "context": t.opt("string"),
  "nonce": t.opt("string"),
});

export const ITransitDecryptOptionsBatch = t.iface([], {
  "batch_input": "ITransitBatchCiphertext",
});

export const ITransitDecryptResponseSingle = t.iface([], {
  "data": t.iface([], {
    "plaintext": t.opt("string"),
  }),
});

export const ITransitDecryptResponseBatch = t.iface([], {
  "data": t.iface([], {
    "batch_results": "ITransitBatchPlaintext",
  }),
});

const exportedTypeSuite: t.ITypeSuite = {
  ITransitKeyType,
  ITransitBatchPlaintext,
  ITransitBatchCiphertext,
  ITransitCreateOptions,
  ITransitReadResponse,
  ITransitListResponse,
  ITransitUpdateOptions,
  ITransitExportOptions,
  ITransitExportResponse,
  ITransitEncryptOptionsSingle,
  ITransitEncryptOptionsBatch,
  ITransitEncryptResponseSingle,
  ITransitEncryptResponseBatch,
  ITransitDecryptOptionsSingle,
  ITransitDecryptOptionsBatch,
  ITransitDecryptResponseSingle,
  ITransitDecryptResponseBatch,
};
export default exportedTypeSuite;
