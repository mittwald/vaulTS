/**
 * This module was automatically generated by `ts-interface-builder`
 */
import * as t from "ts-interface-checker";
// tslint:disable:object-literal-key-quotes

export const ITransitKeyType = t.union(t.lit("aes256-gcm96"), t.lit("chacha20-poly1305"), t.lit("d25519"), t.lit("ecdsa-p256"), t.lit("rsa-2048"), t.lit("rsa-4096"));

export const ITransitSignHashAlgorithm = t.union(t.lit("sha1"), t.lit("sha2-224"), t.lit("sha2-256"), t.lit("sha2-384"), t.lit("sha2-512"), t.lit("sha3-224"), t.lit("sha3-256"), t.lit("sha3-384"), t.lit("sha3-512"));

export const ITransitSignSignatureAlgorithm = t.union(t.lit("pss"), t.lit("pkcs1v15"));

export const ITransitSignMarshalingAlgorithm = t.union(t.lit("asn1"), t.lit("jws"));

export const ITransitBatchPlaintext = t.array(t.iface([], {
  "plaintext": "string",
  "context": t.opt("string"),
}));

export const ITransitRawBatchPlaintext = t.array(t.iface([], {
  "plaintext": t.opt("string"),
  "context": t.opt("string"),
}));

export const ITransitBatchCiphertext = t.array(t.iface([], {
  "ciphertext": "string",
  "context": t.opt("string"),
}));

export const ITransitSignBatchInput = t.array(t.iface([], {
  "input": "string",
  "context": t.opt("string"),
}));

export const ITransitVerifyBatchInputSignature = t.array(t.iface([], {
  "input": "string",
  "signature": "string",
  "context": t.opt("string"),
}));

export const ITransitVerifyBatchInputHMAC = t.array(t.iface([], {
  "input": "string",
  "hmac": "string",
  "context": t.opt("string"),
}));

export const ITransitSignBatchOutput = t.array(t.iface([], {
  "signature": t.opt("string"),
  "publickey": t.opt("string"),
  "error": t.opt("string"),
}));

export const ITransitCreateOptions = t.iface([], {
  "convergent_encryption": t.opt("boolean"),
  "derived": t.opt("boolean"),
  "exportable": t.opt("boolean"),
  "allow_plaintext_backup": t.opt("boolean"),
  "type": t.opt("ITransitKeyType"),
});

export const ITransitReadResponse = t.iface([], {
  "data": t.iface([], {
    "type": "ITransitKeyType",
    "deletion_allowed": "boolean",
    "derived": "boolean",
    "exportable": "boolean",
    "allow_plaintext_backup": "boolean",
    "keys": t.iface([], {
    }),
    "min_decryption_version": "number",
    "min_encryption_version": "number",
    "name": "string",
    "supports_encryption": "boolean",
    "supports_decryption": "boolean",
    "supports_derivation": "boolean",
    "supports_signing": "boolean",
    "latest_version": t.opt("number"),
  }),
});

export const ITransitListResponse = t.iface([], {
  "data": t.iface([], {
    "keys": t.array("string"),
  }),
  "lease_duration": "number",
  "lease_id": "string",
  "renewable": "boolean",
});

export const ITransitUpdateOptions = t.iface([], {
  "min_decryption_version": t.opt("number"),
  "min_encryption_version": t.opt("number"),
  "deletion_allowed": t.opt("boolean"),
  "exportable": t.opt("boolean"),
  "allow_plaintext_backup": t.opt("boolean"),
});

export const ITransitExportOptions = t.iface([], {
  "key_type": t.union(t.lit("encryption-key"), t.lit("signing-key"), t.lit("hmac-key")),
  "version": t.opt(t.union("string", t.lit("latest"))),
});

export const ITransitExportResponse = t.iface([], {
  "data": t.iface([], {
    "name": "string",
    "keys": t.iface([], {
    }),
    "type": "ITransitKeyType",
  }),
});

export const ITransitEncryptOptionsSingle = t.iface([], {
  "plaintext": "string",
  "context": t.opt("string"),
  "key_version": t.opt("number"),
  "nonce": t.opt("string"),
  "type": t.opt("ITransitKeyType"),
  "convergent_encryption": t.opt("string"),
});

export const ITransitEncryptOptionsBatch = t.iface([], {
  "key_version": t.opt("number"),
  "batch_input": "ITransitBatchPlaintext",
  "type": t.opt("ITransitKeyType"),
  "convergent_encryption": t.opt("string"),
});

export const ITransitEncryptResponseSingle = t.iface([], {
  "data": t.iface([], {
    "ciphertext": "string",
  }),
});

export const ITransitEncryptResponseBatch = t.iface([], {
  "data": t.iface([], {
    "batch_results": "ITransitBatchCiphertext",
  }),
});

export const ITransitDecryptOptionsSingle = t.iface([], {
  "ciphertext": "string",
  "context": t.opt("string"),
  "nonce": t.opt("string"),
});

export const ITransitDecryptOptionsBatch = t.iface([], {
  "batch_input": "ITransitBatchCiphertext",
});

export const ITransitDecryptResponseSingle = t.iface([], {
  "data": t.iface([], {
    "plaintext": t.union("string", "undefined"),
  }),
});

export const ITransitDecryptResponseBatch = t.iface([], {
  "data": t.iface([], {
    "batch_results": "ITransitBatchPlaintext",
  }),
});

export const ITransitDecryptRawResponseBatch = t.iface([], {
  "data": t.iface([], {
    "batch_results": "ITransitRawBatchPlaintext",
  }),
});

export const ITransitSignOptionsSingle = t.iface([], {
  "key_version": t.opt("number"),
  "hash_algorithm": t.opt("ITransitSignHashAlgorithm"),
  "input": "string",
  "context": t.opt("string"),
  "prehashed": t.opt("boolean"),
  "signature_algorithm": t.opt("ITransitSignSignatureAlgorithm"),
  "marshaling_algorithm": t.opt("ITransitSignMarshalingAlgorithm"),
});

export const ITransitSignOptionsBatch = t.iface([], {
  "key_version": t.opt("number"),
  "hash_algorithm": t.opt("ITransitSignHashAlgorithm"),
  "batch_input": "ITransitSignBatchInput",
  "prehashed": t.opt("boolean"),
  "signature_algorithm": t.opt("ITransitSignSignatureAlgorithm"),
  "marshaling_algorithm": t.opt("ITransitSignMarshalingAlgorithm"),
});

export const ITransitSignResponseSingle = t.iface([], {
  "data": t.iface([], {
    "signature": t.union("string", "undefined"),
  }),
});

export const ITransitSignResponseBatch = t.iface([], {
  "data": t.iface([], {
    "batch_results": "ITransitSignBatchOutput",
  }),
});

export const ITransitVerifyOptionsSingle = t.iface([], {
  "input": "string",
  "signature": t.opt("string"),
  "hmac": t.opt("string"),
  "hash_algorithm": t.opt("ITransitSignHashAlgorithm"),
  "context": t.opt("string"),
  "prehashed": t.opt("boolean"),
  "signature_algorithm": t.opt("ITransitSignSignatureAlgorithm"),
  "marshaling_algorithm": t.opt("ITransitSignMarshalingAlgorithm"),
});

export const ITransitVerifyOptionsBatch = t.iface([], {
  "batch_input": t.union("ITransitVerifyBatchInputSignature", "ITransitVerifyBatchInputHMAC"),
  "hash_algorithm": t.opt("ITransitSignHashAlgorithm"),
  "prehashed": t.opt("boolean"),
  "signature_algorithm": t.opt("ITransitSignSignatureAlgorithm"),
  "marshaling_algorithm": t.opt("ITransitSignMarshalingAlgorithm"),
});

export const ITransitVerifyResponseSingle = t.iface([], {
  "data": t.iface([], {
    "valid": "boolean",
  }),
});

export const ITransitVerifyResponseBatch = t.iface([], {
  "data": t.iface([], {
    "batch_results": t.array(t.iface([], {
      "valid": "boolean",
    })),
  }),
});

const exportedTypeSuite: t.ITypeSuite = {
  ITransitKeyType,
  ITransitSignHashAlgorithm,
  ITransitSignSignatureAlgorithm,
  ITransitSignMarshalingAlgorithm,
  ITransitBatchPlaintext,
  ITransitRawBatchPlaintext,
  ITransitBatchCiphertext,
  ITransitSignBatchInput,
  ITransitVerifyBatchInputSignature,
  ITransitVerifyBatchInputHMAC,
  ITransitSignBatchOutput,
  ITransitCreateOptions,
  ITransitReadResponse,
  ITransitListResponse,
  ITransitUpdateOptions,
  ITransitExportOptions,
  ITransitExportResponse,
  ITransitEncryptOptionsSingle,
  ITransitEncryptOptionsBatch,
  ITransitEncryptResponseSingle,
  ITransitEncryptResponseBatch,
  ITransitDecryptOptionsSingle,
  ITransitDecryptOptionsBatch,
  ITransitDecryptResponseSingle,
  ITransitDecryptResponseBatch,
  ITransitDecryptRawResponseBatch,
  ITransitSignOptionsSingle,
  ITransitSignOptionsBatch,
  ITransitSignResponseSingle,
  ITransitSignResponseBatch,
  ITransitVerifyOptionsSingle,
  ITransitVerifyOptionsBatch,
  ITransitVerifyResponseSingle,
  ITransitVerifyResponseBatch,
};
export default exportedTypeSuite;
